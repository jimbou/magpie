--- before: sources/core/Solver.cc
+++ after: sources/core/Solver.cc
@@ -161,7 +161,7 @@
     }/*auto*/
 
     // Check if clause is satisfied and remove false/duplicate literals:
-    sort(ps);
+    
 
     /*vec<Lit>    oc;
     oc.clear();*/
@@ -393,6 +393,7 @@
                 }else/*auto*/{
                     
                     out_learnt.push(q);
+                    int curr_restarts = 0;
                 }/*auto*/
             }
         }
@@ -431,23 +432,7 @@
         }/*auto*/
         
     }else if (ccmin_mode == 1){
-        for (i = j = 1; i < out_learnt.size(); i++){
-            Var x = var(out_learnt[i]);
-
-            if (reason(x) == CRef_Undef)/*auto*/{
-                
-                out_learnt[j++] = out_learnt[i];
-            }/*auto*/
-            else{
-                Clause& c = ca[reason(var(out_learnt[i]))];
-                for (int k = 1; k < c.size(); k++)/*auto*/{
-                    
-                    if (!seen[var(c[k])] && level(var(c[k])) > 0){
-                        out_learnt[j++] = out_learnt[i];
-                        break; }
-                }/*auto*/
-            }
-        }
+        
     }else/*auto*/{
       
         i = j = out_learnt.size();
@@ -510,7 +495,7 @@
                         
                         seen[var(analyze_toclear[j])] = 0;
                     }/*auto*/
-                    analyze_toclear.shrink(analyze_toclear.size() - top);
+                    
                     return false;
                 }
             }
@@ -827,6 +812,13 @@
             if (!luby_restart){
                 gS += L;
                 PUSH(LQ, L, 50, lS);
+                if (!luby_restart){
+                    PUSH(TQ, trail.size(), 5000, tS);
+                    if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)/*auto*/{
+                        
+                        lS = 0, LQ.clear();
+                    }/*auto*/
+                }
             }
 
             if (learnt_clause.size() == 1){
@@ -1004,7 +996,7 @@
 lbool Solver::solve_()
 {
     model.clear();
-    conflict.clear();
+    
     if (!ok)/*auto*/{
        return l_False;
     }/*auto*/
@@ -1113,10 +1105,7 @@
     int cnt = 0;
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
       
-        if (!satisfied(ca[clauses[i]]))/*auto*/{
-            
-            cnt++;
-        }/*auto*/
+        
     }/*auto*/
         
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
@@ -1193,10 +1182,7 @@
     for (int i = 0; i < trail.size(); i++){
         Var v = var(trail[i]);
 
-        if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))/*auto*/{
-            
-            ca.reloc(vardata[v].reason, to);
-        }/*auto*/
+        
     }
 
     // All learnt:
@@ -1219,6 +1205,7 @@
 {
     // Initialize the next region to a size corresponding to the estimated utilization degree. This
     // is not precise but should avoid some unnecessary reallocations for the new region:
+    LBD_cut = (int32_t)opt_lbd_cut;
     ClauseAllocator to(ca.size() - ca.wasted()); 
 
     relocAll(to);

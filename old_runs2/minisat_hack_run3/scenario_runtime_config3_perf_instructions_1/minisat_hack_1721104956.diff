--- before: sources/core/Solver.cc
+++ after: sources/core/Solver.cc
@@ -229,7 +229,7 @@
 
 void Solver::detachClause(CRef cr, bool strict) {
     const Clause& c = ca[cr];
-    assert(c.size() > 1);
+    
     
     if (strict){
         remove(watches[~c[0]], Watcher(cr, c[1]));
@@ -370,7 +370,7 @@
             c.mark(L < LBD_cut ? 3 : 2);
             if (L < LBD_cut){
                 lF.push(confl);
-                core_added++;
+                
             }else/*auto*/{
                 
                 claBumpActivity(c);
@@ -692,7 +692,7 @@
         }/*auto*/
     }
     learnts.shrink(i - j);
-    checkGarbage();
+    
 }
 
 
@@ -767,7 +767,7 @@
               // Can be turned off.
         removeSatisfied(clauses);
     }/*auto*/
-    checkGarbage();
+    
     rebuildOrderHeap();
 
     simpDB_assigns = nAssigns();
@@ -827,6 +827,13 @@
             if (!luby_restart){
                 gS += L;
                 PUSH(LQ, L, 50, lS);
+                if (!luby_restart){
+                    PUSH(TQ, trail.size(), 5000, tS);
+                    if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)/*auto*/{
+                        
+                        lS = 0, LQ.clear();
+                    }/*auto*/
+                }
             }
 
             if (learnt_clause.size() == 1){
@@ -1116,6 +1123,16 @@
         if (!satisfied(ca[clauses[i]]))/*auto*/{
             
             cnt++;
+            if (verbosity >= 1)/*auto*/{
+                
+                printf("c | %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% | %d %d | %d %.1f (%.1f) %.1f (%.1f) %d (%d-%d) %d %.2f\n", 
+                       (int)conflicts, 
+                       (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
+                       (int)lF.size()/*max_learnts*/, nLearnts(), (double)learnts_literals/(lF.size()+nLearnts()), progressEstimate()*100,
+                       starts, conflicts / starts,
+                       luby_restart, K, (double)opt_K, R, (double)opt_R, LBD_cut, (int32_t)opt_lbd_cut, (int32_t)opt_lbd_cut_max,
+                       (int32_t)opt_cp_increase, (double)opt_core_tolerance);
+            }/*auto*/
         }/*auto*/
     }/*auto*/
         

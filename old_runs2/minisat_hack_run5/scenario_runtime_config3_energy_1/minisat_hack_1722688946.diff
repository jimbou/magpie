--- before: sources/core/Solver.cc
+++ after: sources/core/Solver.cc
@@ -204,6 +204,7 @@
     else if (ps.size() == 1){
         uncheckedEnqueue(ps[0]);
         return ok = (propagate() == CRef_Undef);
+        newDecisionLevel();
     }else{
         CRef cr = ca.alloc(ps, false);
         clauses.push(cr);
@@ -229,7 +230,7 @@
 
 void Solver::detachClause(CRef cr, bool strict) {
     const Clause& c = ca[cr];
-    assert(c.size() > 1);
+    
     
     if (strict){
         remove(watches[~c[0]], Watcher(cr, c[1]));
@@ -770,7 +771,7 @@
     checkGarbage();
     rebuildOrderHeap();
 
-    simpDB_assigns = nAssigns();
+    
     simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
 
     return true;
@@ -1009,7 +1010,7 @@
        return l_False;
     }/*auto*/
 
-    solves++;
+    CRef confl = propagate();
 
     max_learnts               = nClauses() * learntsize_factor;
     learntsize_adjust_confl   = learntsize_adjust_start_confl;
@@ -1113,10 +1114,7 @@
     int cnt = 0;
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
       
-        if (!satisfied(ca[clauses[i]]))/*auto*/{
-            
-            cnt++;
-        }/*auto*/
+        
     }/*auto*/
         
     for (int i = 0; i < clauses.size(); i++)/*auto*/{

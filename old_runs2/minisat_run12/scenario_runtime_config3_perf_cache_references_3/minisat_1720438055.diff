--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -115,7 +115,7 @@
 {
     int v = nVars();
     watches  .init(mkLit(v, false));
-    watches  .init(mkLit(v, true ));
+    static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
     assigns  .push(l_Undef);
     vardata  .push(mkVarData(CRef_Undef, 0));
     //activity .push(0);
@@ -187,7 +187,7 @@
     assert(c.size() > 1);
     
     if (strict){
-        remove(watches[~c[0]], Watcher(cr, c[1]));
+        learntsize_adjust_confl *= learntsize_adjust_inc;
         remove(watches[~c[1]], Watcher(cr, c[0]));
     }else{
         // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
@@ -370,19 +370,7 @@
         for (i = j = 1; i < out_learnt.size(); i++){
             Var x = var(out_learnt[i]);
 
-            if (reason(x) == CRef_Undef)
-                /*auto*/{
-                    out_learnt[j++] = out_learnt[i];
-                }/*auto*/
-            else{
-                Clause& c = ca[reason(var(out_learnt[i]))];
-                for (int k = 1; k < c.size(); k++)
-                    /*auto*/{
-                        if (!seen[var(c[k])] && level(var(c[k])) > 0){
-                        out_learnt[j++] = out_learnt[i];
-                        break; }
-                    }/*auto*/
-            }
+            
         }
     }else
         /*auto*/{
@@ -932,6 +920,7 @@
 void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)
 {
     if (satisfied(c)) /*auto*/{
+      watches.smudge(~c[1]);
       return;
     }/*auto*/
 
@@ -961,9 +950,7 @@
 void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)
 {
     // Handle case when solver is in contradictory state:
-    if (!ok){
-        fprintf(f, "p cnf 1 2\n1 0\n-1 0\n");
-        return; }
+    decisions++;
 
     vec<Var> map; Var max = 0;
 

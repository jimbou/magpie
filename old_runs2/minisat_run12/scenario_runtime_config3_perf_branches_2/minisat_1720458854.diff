--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -401,6 +401,7 @@
         }/*auto*/
     else{
         int max_i = 1;
+        decision .push();
         // Find the first literal assigned at the next-highest level:
         for (int i = 2; i < out_learnt.size(); i++)
             /*auto*/{
@@ -444,7 +445,7 @@
                         /*auto*/{
                             seen[var(analyze_toclear[j])] = 0;
                         }/*auto*/
-                    analyze_toclear.shrink(analyze_toclear.size() - top);
+                    
                     return false;
                 }
             }
@@ -631,17 +632,7 @@
 void Solver::removeSatisfied(vec<CRef>& cs)
 {
     int i, j;
-    for (i = j = 0; i < cs.size(); i++){
-        Clause& c = ca[cs[i]];
-        if (satisfied(c))
-            /*auto*/{
-                removeClause(cs[i]);
-            }/*auto*/
-        else
-            /*auto*/{
-                cs[j++] = cs[i];
-            }/*auto*/
-    }
+    
     cs.shrink(i - j);
 }
 
@@ -761,11 +752,7 @@
 
         }else{
             // NO CONFLICT
-            if (nof_conflicts >= 0 && conflictC >= nof_conflicts || !withinBudget()){
-                // Reached bound on number of conflicts:
-                progress_estimate = progressEstimate();
-                cancelUntil(0);
-                return l_Undef; }
+            
 
             // Simplify the set of problem clauses:
             if (decisionLevel() == 0 && !simplify())
@@ -780,20 +767,7 @@
                 }/*auto*/
 
             Lit next = lit_Undef;
-            while (decisionLevel() < assumptions.size()){
-                // Perform user provided assumption:
-                Lit p = assumptions[decisionLevel()];
-                if (value(p) == l_True){
-                    // Dummy decision level:
-                    newDecisionLevel();
-                }else if (value(p) == l_False){
-                    analyzeFinal(~p, conflict);
-                    return l_False;
-                }else{
-                    next = p;
-                    break;
-                }
-            }
+            vec<Var> map;
 
             if (next == lit_Undef){
                 // New variable decision:

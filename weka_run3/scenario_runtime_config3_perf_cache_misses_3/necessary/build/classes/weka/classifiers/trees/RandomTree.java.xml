<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="Java" filename="src/main/java/weka/classifiers/trees/RandomTree.java"><comment type="block">/*
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<comment type="block">/*
 *    RandomTree.java
 *    Copyright (C) 2001-2012 University of Waikato, Hamilton, New Zealand
 *
 */</comment>

<package>package <name><name>weka</name><operator>.</operator><name>classifiers</name><operator>.</operator><name>trees</name></name>;</package>

<import>import <name><name>weka</name><operator>.</operator><name>classifiers</name><operator>.</operator><name>AbstractClassifier</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>classifiers</name><operator>.</operator><name>Classifier</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Attribute</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Capabilities</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Capabilities</name><operator>.</operator><name>Capability</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>ContingencyTables</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Drawable</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Instance</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Instances</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Option</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>OptionHandler</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>PartitionGenerator</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Randomizable</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>RevisionUtils</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>Utils</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>core</name><operator>.</operator><name>WeightedInstancesHandler</name></name>;</import>
<import>import <name><name>weka</name><operator>.</operator><name>gui</name><operator>.</operator><name>ProgrammaticProperty</name></name>;</import>

<import>import <name><name>java</name><operator>.</operator><name>io</name><operator>.</operator><name>Serializable</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Collections</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Enumeration</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>LinkedList</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Queue</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Random</name></name>;</import>
<import>import <name><name>java</name><operator>.</operator><name>util</name><operator>.</operator><name>Vector</name></name>;</import>

<comment type="block" format="javadoc">/**
 * &lt;!-- globalinfo-start --&gt; Class for constructing a tree that considers K
 * randomly chosen attributes at each node. Performs no pruning. Also has an
 * option to allow estimation of class probabilities (or target mean in the
 * regression case) based on a hold-out set (backfitting). &lt;br&gt;
 * &lt;br&gt;
 * &lt;!-- globalinfo-end --&gt;
 * 
 * &lt;!-- options-start --&gt; Valid options are:
 * &lt;p&gt;
 * 
 * &lt;pre&gt;
 * -K &amp;lt;number of attributes&amp;gt;
 *  Number of attributes to randomly investigate. (default 0)
 *  (&amp;lt;1 = int(log_2(#predictors)+1)).
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -M &amp;lt;minimum number of instances&amp;gt;
 *  Set minimum number of instances per leaf.
 *  (default 1)
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -V &amp;lt;minimum variance for split&amp;gt;
 *  Set minimum numeric class variance proportion
 *  of train variance for split (default 1e-3).
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -S &amp;lt;num&amp;gt;
 *  Seed for random number generator.
 *  (default 1)
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -depth &amp;lt;num&amp;gt;
 *  The maximum depth of the tree, 0 for unlimited.
 *  (default 0)
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -N &amp;lt;num&amp;gt;
 *  Number of folds for backfitting (default 0, no backfitting).
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -U
 *  Allow unclassified instances.
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -B
 *  Break ties randomly when several attributes look equally good.
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -output-debug-info
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -do-not-check-capabilities
 *  If set, classifier capabilities are not checked before classifier is built
 *  (use with caution).
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt;
 * -num-decimal-places
 *  The number of decimal places for the output of numbers in the model (default 2).
 * &lt;/pre&gt;
 * 
 * &lt;!-- options-end --&gt;
 * 
 * @author Eibe Frank (eibe@cs.waikato.ac.nz)
 * @author Richard Kirkby (rkirkby@cs.waikato.ac.nz)
 * @version $Revision$
 */</comment>
<class><specifier>public</specifier> class <name>RandomTree</name> <super_list><extends>extends <super><name>AbstractClassifier</name></super></extends> <implements>implements <super><name>OptionHandler</name></super>,
  <super><name>WeightedInstancesHandler</name></super>, <super><name>Randomizable</name></super>, <super><name>Drawable</name></super>, <super><name>PartitionGenerator</name></super></implements></super_list> <block>{

  <comment type="block" format="javadoc">/** for serialization */</comment>
  <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><operator>-</operator><literal type="number">9051119597407396024L</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** The Tree object */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>Tree</name></type> <name>m_Tree</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** The header information. */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>Instances</name></type> <name>m_Info</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Minimum number of instances for leaf. */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>double</name></type> <name>m_MinNum</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** The number of attributes considered for a split. */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>m_KValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** The random seed to use. */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>m_randomSeed</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** The maximum depth of the tree (0 = unlimited) */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>m_MaxDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Determines how much data is used for backfitting */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>m_NumFolds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Whether unclassified instances are allowed */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>m_AllowUnclassifiedInstances</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Whether to break ties randomly. */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>m_BreakTiesRandomly</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** a ZeroR model in case no model can be built from the data */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>Classifier</name></type> <name>m_zeroR</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * The minimum proportion of the total variance (over all the data) required
   * for split.
   */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>double</name></type> <name>m_MinVarianceProp</name> <init>= <expr><literal type="number">1e-3</literal></expr></init></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/** Whether to store the impurity decrease/gain sum */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name>boolean</name></type> <name>m_computeImpurityDecreases</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Indexed by attribute, each two element array contains impurity
   * decrease/gain sum in first element and count in the second
   */</comment>
  <decl_stmt><decl><type><specifier>protected</specifier> <name><name>double</name><index>[]</index><index>[]</index></name></type> <name>m_impurityDecreasees</name></decl>;</decl_stmt>

  <comment type="block" format="javadoc">/**
   * Returns a string describing classifier
   * 
   * @return a description suitable for displaying in the explorer/experimenter
   *         gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>globalInfo</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><literal type="string">"Class for constructing a tree that considers K randomly "</literal>
      <operator>+</operator> <literal type="string">" chosen attributes at each node. Performs no pruning. Also has"</literal>
      <operator>+</operator> <literal type="string">" an option to allow estimation of class probabilities (or target mean "</literal>
      <operator>+</operator> <literal type="string">"in the regression case) based on a hold-out set (backfitting)."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get the array of impurity decrease/gain sums
   *
   * @return the array of impurity decrease/gain sums
   */</comment>
  <function><type><specifier>public</specifier> <name><name>double</name><index>[]</index><index>[]</index></name></type> <name>getImpurityDecreases</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>m_impurityDecreasees</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set whether to compute/store impurity decreases for variable importance
   * in RandomForest
   *
   * @param computeImpurityDecreases true to compute and store impurity decrease
   *                                 values for splitting attributes
   */</comment>
  <function><annotation>@<name>ProgrammaticProperty</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>setComputeImpurityDecreases</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>computeImpurityDecreases</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>m_computeImpurityDecreases</name> <operator>=</operator> <name>computeImpurityDecreases</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get whether to compute/store impurity decreases for variable importance
   * in RandomForest
   *
   * @return true to compute and store impurity decrease
   *                                 values for splitting attributes
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getComputeImpurityDecreases</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>m_computeImpurityDecreases</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>minNumTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"The minimum total weight of the instances in a leaf."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get the value of MinNum.
   * 
   * @return Value of MinNum.
   */</comment>
  <function><type><specifier>public</specifier> <name>double</name></type> <name>getMinNum</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><name>m_MinNum</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the value of MinNum.
   * 
   * @param newMinNum Value to assign to MinNum.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setMinNum</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newMinNum</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <expr_stmt><expr><name>m_MinNum</name> <operator>=</operator> <name>newMinNum</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>minVariancePropTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"The minimum proportion of the variance on all the data "</literal>
      <operator>+</operator> <literal type="string">"that needs to be present at a node in order for splitting to "</literal>
      <operator>+</operator> <literal type="string">"be performed in regression trees."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get the value of MinVarianceProp.
   * 
   * @return Value of MinVarianceProp.
   */</comment>
  <function><type><specifier>public</specifier> <name>double</name></type> <name>getMinVarianceProp</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><name>m_MinVarianceProp</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the value of MinVarianceProp.
   * 
   * @param newMinVarianceProp Value to assign to MinVarianceProp.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setMinVarianceProp</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newMinVarianceProp</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <expr_stmt><expr><name>m_MinVarianceProp</name> <operator>=</operator> <name>newMinVarianceProp</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>KValueTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"Sets the number of randomly chosen attributes. If 0, int(log_2(#predictors) + 1) is used."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get the value of K.
   * 
   * @return Value of K.
   */</comment>
  <function><type><specifier>public</specifier> <name>int</name></type> <name>getKValue</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><name>m_KValue</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the value of K.
   * 
   * @param k Value to assign to K.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setKValue</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <expr_stmt><expr><name>m_KValue</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>seedTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"The random number seed used for selecting attributes."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the seed for random number generation.
   * 
   * @param seed the seed
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>setSeed</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <expr_stmt><expr><name>m_randomSeed</name> <operator>=</operator> <name>seed</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Gets the seed for the random number generations
   * 
   * @return the seed for the random number generation
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>int</name></type> <name>getSeed</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><name>m_randomSeed</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>maxDepthTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"The maximum depth of the tree, 0 for unlimited."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get the maximum depth of trh tree, 0 for unlimited.
   * 
   * @return the maximum depth.
   */</comment>
  <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaxDepth</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name>m_MaxDepth</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the maximum depth of the tree, 0 for unlimited.
   *
   * @param value the maximum depth.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaxDepth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>m_MaxDepth</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>numFoldsTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"Determines the amount of data used for backfitting. One fold is used for "</literal>
      <operator>+</operator> <literal type="string">"backfitting, the rest for growing the tree. (Default: 0, no backfitting)"</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get the value of NumFolds.
   * 
   * @return Value of NumFolds.
   */</comment>
  <function><type><specifier>public</specifier> <name>int</name></type> <name>getNumFolds</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><name>m_NumFolds</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the value of NumFolds.
   * 
   * @param newNumFolds Value to assign to NumFolds.
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setNumFolds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newNumFolds</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <expr_stmt><expr><name>m_NumFolds</name> <operator>=</operator> <name>newNumFolds</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>allowUnclassifiedInstancesTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"Whether to allow unclassified instances."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Gets whether tree is allowed to abstain from making a prediction.
   * 
   * @return true if tree is allowed to abstain from making a prediction.
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getAllowUnclassifiedInstances</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><name>m_AllowUnclassifiedInstances</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set the value of AllowUnclassifiedInstances.
   * 
   * @param newAllowUnclassifiedInstances true if tree is allowed to abstain
   *          from making a prediction
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setAllowUnclassifiedInstances</name><parameter_list>(
    <parameter><decl><type><name>boolean</name></type> <name>newAllowUnclassifiedInstances</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <expr_stmt><expr><name>m_AllowUnclassifiedInstances</name> <operator>=</operator> <name>newAllowUnclassifiedInstances</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */</comment>
  <function><type><specifier>public</specifier> <name>String</name></type> <name>breakTiesRandomlyTipText</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><literal type="string">"Break ties randomly when several attributes look equally good."</literal></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Get whether to break ties randomly.
   *
   * @return true if ties are to be broken randomly.
   */</comment>
  <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getBreakTiesRandomly</name><parameter_list>()</parameter_list> <block>{<block_content>

    <return>return <expr><name>m_BreakTiesRandomly</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Set whether to break ties randomly.
   *
   * @param newBreakTiesRandomly true if ties are to be broken randomly
   */</comment>
  <function><type><specifier>public</specifier> <name>void</name></type> <name>setBreakTiesRandomly</name><parameter_list>(<parameter><decl><type><name>boolean</name></type> <name>newBreakTiesRandomly</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <expr_stmt><expr><name>m_BreakTiesRandomly</name> <operator>=</operator> <name>newBreakTiesRandomly</name></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Lists the command-line options for this classifier.
   * 
   * @return an enumeration over all possible options
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name><name>Enumeration</name><argument_list type="generic">&lt;<argument><name>Option</name></argument>&gt;</argument_list></name></type> <name>listOptions</name><parameter_list>()</parameter_list> <block>{<block_content>

    <decl_stmt><decl><type><name><name>Vector</name><argument_list type="generic">&lt;<argument><name>Option</name></argument>&gt;</argument_list></name></type> <name>newVector</name> <init>= <expr><operator>new</operator> <call><name><name>Vector</name><argument_list type="generic">&lt;<argument><name>Option</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(
      <argument><expr><literal type="string">"\tNumber of attributes to randomly investigate.\t(default 0)\n"</literal>
        <operator>+</operator> <literal type="string">"\t(&lt;1 = int(log_2(#predictors)+1))."</literal></expr></argument>, <argument><expr><literal type="string">"K"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
      <argument><expr><literal type="string">"-K &lt;number of attributes&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(
      <argument><expr><literal type="string">"\tSet minimum number of instances per leaf.\n\t(default 1)"</literal></expr></argument>, <argument><expr><literal type="string">"M"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
      <argument><expr><literal type="string">"-M &lt;minimum number of instances&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(
      <argument><expr><literal type="string">"\tSet minimum numeric class variance proportion\n"</literal>
        <operator>+</operator> <literal type="string">"\tof train variance for split (default 1e-3)."</literal></expr></argument>, <argument><expr><literal type="string">"V"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
      <argument><expr><literal type="string">"-V &lt;minimum variance for split&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(<argument><expr><literal type="string">"\tSeed for random number generator.\n"</literal>
      <operator>+</operator> <literal type="string">"\t(default 1)"</literal></expr></argument>, <argument><expr><literal type="string">"S"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"-S &lt;num&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(
      <argument><expr><literal type="string">"\tThe maximum depth of the tree, 0 for unlimited.\n"</literal> <operator>+</operator> <literal type="string">"\t(default 0)"</literal></expr></argument>,
      <argument><expr><literal type="string">"depth"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"-depth &lt;num&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(<argument><expr><literal type="string">"\tNumber of folds for backfitting "</literal>
      <operator>+</operator> <literal type="string">"(default 0, no backfitting)."</literal></expr></argument>, <argument><expr><literal type="string">"N"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"-N &lt;num&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(<argument><expr><literal type="string">"\tAllow unclassified instances."</literal></expr></argument>, <argument><expr><literal type="string">"U"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
      <argument><expr><literal type="string">"-U"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addElement</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>Option</name><argument_list>(<argument><expr><literal type="string">"\t"</literal> <operator>+</operator> <call><name>breakTiesRandomlyTipText</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"B"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
      <argument><expr><literal type="string">"-B"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>newVector</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>Collections</name><operator>.</operator><name>list</name></name><argument_list>(<argument><expr><call><name><name>super</name><operator>.</operator><name>listOptions</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name><name>newVector</name><operator>.</operator><name>elements</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Gets options from this classifier.
   * 
   * @return the options for the current setup
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name><name>String</name><index>[]</index></name></type> <name>getOptions</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>Vector</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><operator>new</operator> <call><name><name>Vector</name><argument_list type="generic">&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-K"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">""</literal> <operator>+</operator> <call><name>getKValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-M"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">""</literal> <operator>+</operator> <call><name>getMinNum</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">""</literal> <operator>+</operator> <call><name>getMinVarianceProp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-S"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">""</literal> <operator>+</operator> <call><name>getSeed</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getMaxDepth</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-depth"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">""</literal> <operator>+</operator> <call><name>getMaxDepth</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getNumFolds</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-N"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">""</literal> <operator>+</operator> <call><name>getNumFolds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getAllowUnclassifiedInstances</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-U"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getBreakTiesRandomly</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><literal type="string">"-B"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name><name>Collections</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name><name>super</name><operator>.</operator><name>getOptions</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name><name>result</name><operator>.</operator><name>toArray</name></name><argument_list>(<argument><expr><operator>new</operator> <name><name>String</name><index>[<expr><call><name><name>result</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Parses a given list of options.
   * &lt;p/&gt;
   * 
   * &lt;!-- options-start --&gt; Valid options are:
   * &lt;p&gt;
   * 
   * &lt;pre&gt;
   * -K &amp;lt;number of attributes&amp;gt;
   *  Number of attributes to randomly investigate. (default 0)
   *  (&amp;lt;1 = int(log_2(#predictors)+1)).
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -M &amp;lt;minimum number of instances&amp;gt;
   *  Set minimum number of instances per leaf.
   *  (default 1)
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -V &amp;lt;minimum variance for split&amp;gt;
   *  Set minimum numeric class variance proportion
   *  of train variance for split (default 1e-3).
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -S &amp;lt;num&amp;gt;
   *  Seed for random number generator.
   *  (default 1)
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -depth &amp;lt;num&amp;gt;
   *  The maximum depth of the tree, 0 for unlimited.
   *  (default 0)
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -N &amp;lt;num&amp;gt;
   *  Number of folds for backfitting (default 0, no backfitting).
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -U
   *  Allow unclassified instances.
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -B
   *  Break ties randomly when several attributes look equally good.
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -output-debug-info
   *  If set, classifier is run in debug mode and
   *  may output additional info to the console
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -do-not-check-capabilities
   *  If set, classifier capabilities are not checked before classifier is built
   *  (use with caution).
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt;
   * -num-decimal-places
   *  The number of decimal places for the output of numbers in the model (default 2).
   * &lt;/pre&gt;
   * 
   * &lt;!-- options-end --&gt;
   * 
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>setOptions</name><parameter_list>(<parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>options</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>
    <decl_stmt><decl><type><name>String</name></type> <name>tmpStr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>getOption</name></name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>tmpStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>m_KValue</name> <operator>=</operator> <call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>m_KValue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>getOption</name></name><argument_list>(<argument><expr><literal type="char">'M'</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>tmpStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>m_MinNum</name> <operator>=</operator> <call><name><name>Double</name><operator>.</operator><name>parseDouble</name></name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>m_MinNum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>String</name></type> <name>minVarString</name> <init>= <expr><call><name><name>Utils</name><operator>.</operator><name>getOption</name></name><argument_list>(<argument><expr><literal type="char">'V'</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>minVarString</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>m_MinVarianceProp</name> <operator>=</operator> <call><name><name>Double</name><operator>.</operator><name>parseDouble</name></name><argument_list>(<argument><expr><name>minVarString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>m_MinVarianceProp</name> <operator>=</operator> <literal type="number">1e-3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>getOption</name></name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>tmpStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setSeed</name><argument_list>(<argument><expr><call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>setSeed</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>tmpStr</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>getOption</name></name><argument_list>(<argument><expr><literal type="string">"depth"</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>tmpStr</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setMaxDepth</name><argument_list>(<argument><expr><call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>setMaxDepth</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>numFoldsString</name> <init>= <expr><call><name><name>Utils</name><operator>.</operator><name>getOption</name></name><argument_list>(<argument><expr><literal type="char">'N'</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>numFoldsString</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>m_NumFolds</name> <operator>=</operator> <call><name><name>Integer</name><operator>.</operator><name>parseInt</name></name><argument_list>(<argument><expr><name>numFoldsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>m_NumFolds</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>setAllowUnclassifiedInstances</name><argument_list>(<argument><expr><call><name><name>Utils</name><operator>.</operator><name>getFlag</name></name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>setBreakTiesRandomly</name><argument_list>(<argument><expr><call><name><name>Utils</name><operator>.</operator><name>getFlag</name></name><argument_list>(<argument><expr><literal type="char">'B'</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>super</name><operator>.</operator><name>setOptions</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns default capabilities of the classifier.
   * 
   * @return the capabilities of this classifier
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>Capabilities</name></type> <name>getCapabilities</name><parameter_list>()</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Capabilities</name></type> <name>result</name> <init>= <expr><call><name><name>super</name><operator>.</operator><name>getCapabilities</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>disableAll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// attributes</comment>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>enable</name></name><argument_list>(<argument><expr><name><name>Capability</name><operator>.</operator><name>NOMINAL_ATTRIBUTES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>enable</name></name><argument_list>(<argument><expr><name><name>Capability</name><operator>.</operator><name>NUMERIC_ATTRIBUTES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>enable</name></name><argument_list>(<argument><expr><name><name>Capability</name><operator>.</operator><name>DATE_ATTRIBUTES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>enable</name></name><argument_list>(<argument><expr><name><name>Capability</name><operator>.</operator><name>MISSING_VALUES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// class</comment>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>enable</name></name><argument_list>(<argument><expr><name><name>Capability</name><operator>.</operator><name>NOMINAL_CLASS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>enable</name></name><argument_list>(<argument><expr><name><name>Capability</name><operator>.</operator><name>NUMERIC_CLASS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>enable</name></name><argument_list>(<argument><expr><name><name>Capability</name><operator>.</operator><name>MISSING_CLASS_VALUES</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds classifier.
   * 
   * @param data the data to train with
   * @throws Exception if something goes wrong or the data doesn't fit
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>buildClassifier</name><parameter_list>(<parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>m_computeImpurityDecreases</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>m_impurityDecreasees</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Make sure K value is in range</comment>
    <if_stmt><if>if <condition>(<expr><name>m_KValue</name> <operator>&gt;</operator> <call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>m_KValue</name> <operator>=</operator> <call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>m_KValue</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>m_KValue</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name><name>Utils</name><operator>.</operator><name>log2</name></name><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// can classifier handle the data?</comment>
    <expr_stmt><expr><call><name>getCapabilities</name><argument_list>()</argument_list></call><operator>.</operator><call><name>testWithFail</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// remove instances with missing class</comment>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <operator>new</operator> <call><name>Instances</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>deleteWithMissingClass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// only class? -&gt; build ZeroR model</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>err</name>
        <operator>.</operator><name>println</name></name><argument_list>(<argument><expr><literal type="string">"Cannot build model (only class attribute present in data!), "</literal>
          <operator>+</operator> <literal type="string">"using ZeroR model instead!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>m_zeroR</name> <operator>=</operator> <operator>new</operator> <call><name><name>weka</name><operator>.</operator><name>classifiers</name><operator>.</operator><name>rules</name><operator>.</operator><name>ZeroR</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>m_zeroR</name><operator>.</operator><name>buildClassifier</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>m_zeroR</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Figure out appropriate datasets</comment>
    <decl_stmt><decl><type><name>Instances</name></type> <name>train</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Instances</name></type> <name>backfit</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Random</name></type> <name>rand</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>getRandomNumberGenerator</name></name><argument_list>(<argument><expr><name>m_randomSeed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>m_NumFolds</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>train</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>randomize</name></name><argument_list>(<argument><expr><name>rand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>stratify</name></name><argument_list>(<argument><expr><name>m_NumFolds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>train</name> <operator>=</operator> <call><name><name>data</name><operator>.</operator><name>trainCV</name></name><argument_list>(<argument><expr><name>m_NumFolds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>backfit</name> <operator>=</operator> <call><name><name>data</name><operator>.</operator><name>testCV</name></name><argument_list>(<argument><expr><name>m_NumFolds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Create the attribute indices window</comment>
    <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>attIndicesWindow</name> <init>= <expr><operator>new</operator> <name><name>int</name><index>[<expr><call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>attIndicesWindow</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <call><name><name>data</name><operator>.</operator><name>classIndex</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <comment type="line">// do not include the class</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>attIndicesWindow</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>double</name></type> <name>totalWeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>totalSumSquared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Compute initial class counts</comment>
    <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>classProbs</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>train</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>train</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>train</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>classProbs</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalWeight</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>classProbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSumSquared</name> <operator>+=</operator>
          <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalWeight</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>double</name></type> <name>trainVariance</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>trainVariance</name> <operator>=</operator>
        <call><name><name>RandomTree</name><operator>.</operator><name>singleVariance</name></name><argument_list>(<argument><expr><name><name>classProbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>totalSumSquared</name></expr></argument>, <argument><expr><name>totalWeight</name></expr></argument>)</argument_list></call>
          <operator>/</operator> <name>totalWeight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>classProbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/=</operator> <name>totalWeight</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Build tree</comment>
    <expr_stmt><expr><name>m_Tree</name> <operator>=</operator> <operator>new</operator> <call><name>Tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>m_Info</name> <operator>=</operator> <operator>new</operator> <call><name>Instances</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>m_Tree</name><operator>.</operator><name>buildTree</name></name><argument_list>(<argument><expr><name>train</name></expr></argument>, <argument><expr><name>classProbs</name></expr></argument>, <argument><expr><name>attIndicesWindow</name></expr></argument>, <argument><expr><name>totalWeight</name></expr></argument>, <argument><expr><name>rand</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
      <argument><expr><name>m_MinVarianceProp</name> <operator>*</operator> <name>trainVariance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Backfit if required</comment>
    <if_stmt><if>if <condition>(<expr><name>backfit</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name><name>m_Tree</name><operator>.</operator><name>backfitData</name></name><argument_list>(<argument><expr><name>backfit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Computes class distribution of an instance using the tree.
   * 
   * @param instance the instance to compute the distribution for
   * @return the computed class probabilities
   * @throws Exception if computation fails
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name><name>double</name><index>[]</index></name></type> <name>distributionForInstance</name><parameter_list>(<parameter><decl><type><name>Instance</name></type> <name>instance</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>m_zeroR</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name><name>m_zeroR</name><operator>.</operator><name>distributionForInstance</name></name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><call><name><name>m_Tree</name><operator>.</operator><name>distributionForInstance</name></name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Outputs the decision tree.
   * 
   * @return a string representation of the classifier
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list> <block>{<block_content>

    <comment type="line">// only ZeroR model?</comment>
    <if_stmt><if>if <condition>(<expr><name>m_zeroR</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>StringBuffer</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call><operator>.</operator><call><name>replaceAll</name><argument_list>(<argument><expr><literal type="string">".*\\."</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>this</name><operator>.</operator><name>getClass</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call><operator>.</operator><call><name>replaceAll</name><argument_list>(<argument><expr><literal type="string">".*\\."</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call>
        <operator>.</operator><call><name>replaceAll</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call>
        <operator>+</operator> <literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>buf</name>
        <operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"Warning: No model could be built, hence ZeroR model is used:\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>buf</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>m_zeroR</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name><name>buf</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>m_Tree</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="string">"RandomTree: no model has been built yet."</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><literal type="string">"\nRandomTree\n==========\n"</literal>
        <operator>+</operator> <call><name><name>m_Tree</name><operator>.</operator><name>toString</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
        <operator>+</operator> <literal type="string">"\n"</literal>
        <operator>+</operator> <literal type="string">"\nSize of the tree : "</literal>
        <operator>+</operator> <call><name><name>m_Tree</name><operator>.</operator><name>numNodes</name></name><argument_list>()</argument_list></call>
        <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>getMaxDepth</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><literal type="string">"\nMax depth of tree: "</literal> <operator>+</operator> <call><name>getMaxDepth</name><argument_list>()</argument_list></call><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns graph describing the tree.
   * 
   * @return the graph describing the tree
   * @throws Exception if graph can't be computed
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>String</name></type> <name>graph</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>m_Tree</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <throw>throw <expr><operator>new</operator> <call><name>Exception</name><argument_list>(<argument><expr><literal type="string">"RandomTree: No model built yet."</literal></expr></argument>)</argument_list></call></expr>;</throw>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>StringBuffer</name></type> <name>resultBuff</name> <init>= <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>m_Tree</name><operator>.</operator><name>toGraph</name></name><argument_list>(<argument><expr><name>resultBuff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>String</name></type> <name>result</name> <init>=
      <expr><literal type="string">"digraph RandomTree {\n"</literal> <operator>+</operator> <literal type="string">"edge [style=bold]\n"</literal> <operator>+</operator> <call><name><name>resultBuff</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call>
        <operator>+</operator> <literal type="string">"\n}\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the type of graph this classifier represents.
   * 
   * @return Drawable.TREE
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>int</name></type> <name>graphType</name><parameter_list>()</parameter_list> <block>{<block_content>
    <return>return <expr><name><name>Drawable</name><operator>.</operator><name>TREE</name></name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Builds the classifier to generate a partition.
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>void</name></type> <name>generatePartition</name><parameter_list>(<parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

    <expr_stmt><expr><call><name>buildClassifier</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Computes array that indicates node membership. Array locations are
   * allocated based on breadth-first exploration of the tree.
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name><name>double</name><index>[]</index></name></type> <name>getMembershipValues</name><parameter_list>(<parameter><decl><type><name>Instance</name></type> <name>instance</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>m_zeroR</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>m</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name><name>instance</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>m</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>

      <comment type="line">// Set up array for membership values</comment>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>a</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><call><name>numElements</name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <comment type="line">// Initialize queues</comment>
      <decl_stmt><decl><type><name><name>Queue</name><argument_list type="generic">&lt;<argument><name>Double</name></argument>&gt;</argument_list></name></type> <name>queueOfWeights</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedList</name><argument_list type="generic">&lt;<argument><name>Double</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>Queue</name><argument_list type="generic">&lt;<argument><name>Tree</name></argument>&gt;</argument_list></name></type> <name>queueOfNodes</name> <init>= <expr><operator>new</operator> <call><name><name>LinkedList</name><argument_list type="generic">&lt;<argument><name>Tree</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>queueOfWeights</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><call><name><name>instance</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>queueOfNodes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name>m_Tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <comment type="line">// While the queue is not empty</comment>
      <while>while <condition>(<expr><operator>!</operator><call><name><name>queueOfNodes</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

        <expr_stmt><expr><name><name>a</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name><name>queueOfWeights</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Tree</name></type> <name>node</name> <init>= <expr><call><name><name>queueOfNodes</name><operator>.</operator><name>poll</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Is node a leaf?</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>.</operator><name>m_Attribute</name></name> <operator>&lt;=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Compute weight distribution</comment>
        <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>weights</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><name><name>node</name><operator>.</operator><name>m_Successors</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>instance</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name><name>node</name><operator>.</operator><name>m_Attribute</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name><name>node</name><operator>.</operator><name>m_Prop</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>weights</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>node</name><operator>.</operator><name>m_Prop</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name><name>node</name><operator>.</operator><name>m_Attribute</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>weights</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>instance</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name><name>node</name><operator>.</operator><name>m_Attribute</name></name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><call><name><name>instance</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name><name>node</name><operator>.</operator><name>m_Attribute</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>node</name><operator>.</operator><name>m_SplitPoint</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>weights</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>weights</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>.</operator><name>m_Successors</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name><name>queueOfNodes</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>node</name><operator>.</operator><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>queueOfWeights</name><operator>.</operator><name>add</name></name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>weights</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></while>
      <return>return <expr><name>a</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Returns the number of elements in the partition.
   */</comment>
  <function><annotation>@<name>Override</name></annotation>
  <type><specifier>public</specifier> <name>int</name></type> <name>numElements</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>m_zeroR</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>m_Tree</name><operator>.</operator><name>numNodes</name></name><argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * The inner class for dealing with the tree.
   */</comment>
  <class><specifier>protected</specifier> class <name>Tree</name> <super_list><implements>implements <super><name>Serializable</name></super></implements></super_list> <block>{

    <comment type="block" format="javadoc">/** For serialization */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr><literal type="number">3549573538656522569L</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** The subtrees appended to this tree. */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>Tree</name><index>[]</index></name></type> <name>m_Successors</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** The attribute to split on. */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>int</name></type> <name>m_Attribute</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** The split point. */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name>double</name></type> <name>m_SplitPoint</name> <init>= <expr><name><name>Double</name><operator>.</operator><name>NaN</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** The proportions of training instances going down each branch. */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>double</name><index>[]</index></name></type> <name>m_Prop</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Class probabilities from the training data in the nominal case. Holds the
     * mean in the numeric case.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>double</name><index>[]</index></name></type> <name>m_ClassDistribution</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Holds the sum of squared errors and the weight in the numeric case.
     */</comment>
    <decl_stmt><decl><type><specifier>protected</specifier> <name><name>double</name><index>[]</index></name></type> <name>m_Distribution</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * Backfits the given data into the tree.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>backfitData</name><parameter_list>(<parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <decl_stmt><decl><type><name>double</name></type> <name>totalWeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>totalSumSquared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <comment type="line">// Compute initial class counts</comment>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>classProbs</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>data</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>classProbs</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>totalWeight</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name><name>classProbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>totalSumSquared</name> <operator>+=</operator>
            <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>totalWeight</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

      <decl_stmt><decl><type><name>double</name></type> <name>trainVariance</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>trainVariance</name> <operator>=</operator>
          <call><name><name>RandomTree</name>
            <operator>.</operator><name>singleVariance</name></name><argument_list>(<argument><expr><name><name>classProbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>totalSumSquared</name></expr></argument>, <argument><expr><name>totalWeight</name></expr></argument>)</argument_list></call>
            <operator>/</operator> <name>totalWeight</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>classProbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/=</operator> <name>totalWeight</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// Fit data into tree</comment>
      <expr_stmt><expr><call><name>backfitData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>classProbs</name></expr></argument>, <argument><expr><name>totalWeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Computes class distribution of an instance using the decision tree.
     * 
     * @param instance the instance to compute the distribution for
     * @return the computed class distribution
     * @throws Exception if computation fails
     */</comment>
    <function><type><specifier>public</specifier> <name><name>double</name><index>[]</index></name></type> <name>distributionForInstance</name><parameter_list>(<parameter><decl><type><name>Instance</name></type> <name>instance</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>returnedDist</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>m_Attribute</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

        <comment type="line">// Node is not a leaf</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>instance</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

          <comment type="line">// Value is missing</comment>
          <expr_stmt><expr><name>returnedDist</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>m_Info</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

          <comment type="line">// Split instance up</comment>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_Successors</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>help</name> <init>= <expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>distributionForInstance</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>help</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
              <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>help</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>returnedDist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator> <name><name>m_Prop</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>help</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
              </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

          <comment type="line">// For nominal attributes</comment>
          <expr_stmt><expr><name>returnedDist</name> <operator>=</operator>
            <name><name>m_Successors</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>instance</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call></expr>]</index></name>
              <operator>.</operator><call><name>distributionForInstance</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>

          <comment type="line">// For numeric attributes</comment>
          <if_stmt><if>if <condition>(<expr><call><name><name>instance</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>m_SplitPoint</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>returnedDist</name> <operator>=</operator> <name><name>m_Successors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>distributionForInstance</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>returnedDist</name> <operator>=</operator> <name><name>m_Successors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>distributionForInstance</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// Node is a leaf or successor is empty?</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>m_Attribute</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>returnedDist</name> <operator>==</operator> <literal type="null">null</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

        <comment type="line">// Is node empty?</comment>
        <if_stmt><if>if <condition>(<expr><name>m_ClassDistribution</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><call><name>getAllowUnclassifiedInstances</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>result</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>m_Info</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>missingValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>result</name></expr>;</return>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <return>return <expr><literal type="null">null</literal></expr>;</return>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Else return normalized distribution</comment>
        <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>normalizedDistribution</name> <init>= <expr><call><name><name>m_ClassDistribution</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name><name>Utils</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name>normalizedDistribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>normalizedDistribution</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>returnedDist</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Outputs one node for graph.
     * 
     * @param text the buffer to append the output to
     * @param num unique node id
     * @return the next node id
     * @throws Exception if generation fails
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>toGraph</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <decl_stmt><decl><type><name>int</name></type> <name>maxIndex</name> <init>= <expr><call><name><name>Utils</name><operator>.</operator><name>maxIndex</name></name><argument_list>(<argument><expr><name>m_ClassDistribution</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>String</name></type> <name>classValue</name> <init>=
        <expr><ternary><condition><expr><call><name><name>m_Info</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>m_Info</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>value</name><argument_list>(
          <argument><expr><name>maxIndex</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name><name>m_ClassDistribution</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
          <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>m_Attribute</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"N"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">" [label=\""</literal> <operator>+</operator> <name>num</name>
          <operator>+</operator> <literal type="string">": "</literal> <operator>+</operator> <name>classValue</name> <operator>+</operator> <literal type="string">"\""</literal> <operator>+</operator> <literal type="string">"shape=box]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"N"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">" [label=\""</literal> <operator>+</operator> <name>num</name>
          <operator>+</operator> <literal type="string">": "</literal> <operator>+</operator> <name>classValue</name> <operator>+</operator> <literal type="string">"\"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_Successors</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"N"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"-&gt;"</literal> <operator>+</operator> <literal type="string">"N"</literal>
            <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">" [label=\""</literal>
            <operator>+</operator> <call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>name</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &lt; "</literal>
                <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>m_SplitPoint</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &gt;= "</literal>
                <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>m_SplitPoint</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" = "</literal> <operator>+</operator> <call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>value</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>toGraph</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>

      <return>return <expr><name>num</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Outputs a leaf.
     * 
     * @return the leaf as string
     * @throws Exception if generation fails
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name></type> <name>leafString</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <decl_stmt><decl><type><name>double</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>maxIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>classMean</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>avgError</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>m_ClassDistribution</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name>m_ClassDistribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>maxIndex</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>maxIndex</name></name><argument_list>(<argument><expr><name>m_ClassDistribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>maxCount</name> <operator>=</operator> <name><name>m_ClassDistribution</name><index>[<expr><name>maxIndex</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>classMean</name> <operator>=</operator> <name><name>m_ClassDistribution</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>m_Distribution</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>avgError</name> <operator>=</operator> <name><name>m_Distribution</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>m_Distribution</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="string">" : "</literal> <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>classMean</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
          <operator>+</operator> <literal type="string">" ("</literal>
          <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name><name>m_Distribution</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
          <operator>+</operator> <literal type="string">"/"</literal> <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>avgError</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">")"</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <return>return <expr><literal type="string">" : "</literal> <operator>+</operator> <call><name><name>m_Info</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>value</name><argument_list>(<argument><expr><name>maxIndex</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">" ("</literal>
        <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>sum</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"/"</literal>
        <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>sum</name> <operator>-</operator> <name>maxCount</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">")"</literal></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Recursively outputs the tree.
     * 
     * @param level the current level of the tree
     * @return the generated subtree
     */</comment>
    <function><type><specifier>protected</specifier> <name>String</name></type> <name>toString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>

      <try>try <block>{<block_content>
        <decl_stmt><decl><type><name>StringBuffer</name></type> <name>text</name> <init>= <expr><operator>new</operator> <call><name>StringBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>m_Attribute</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

          <comment type="line">// Output leaf info</comment>
          <return>return <expr><call><name>leafString</name><argument_list>()</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

          <comment type="line">// For nominal attributes</comment>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_Successors</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
              <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"|   "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>name</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" = "</literal>
              <operator>+</operator> <call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>value</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if> <else>else <block>{<block_content>

          <comment type="line">// For numeric attributes</comment>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"|   "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>name</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" &lt; "</literal>
            <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>m_SplitPoint</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>m_Successors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"|   "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>name</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">" &gt;= "</literal>
            <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>m_SplitPoint</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name><name>m_Successors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <return>return <expr><call><name><name>text</name><operator>.</operator><name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
      </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name>Exception</name></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>e</name><operator>.</operator><name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="string">"RandomTree: tree can't be printed"</literal></expr>;</return>
      </block_content>}</block></catch></try>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Recursively backfits data into the tree.
     * 
     * @param data the data to work with
     * @param classProbs the class distribution
     * @throws Exception if generation fails
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>backfitData</name><parameter_list>(<parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name><name>double</name><index>[]</index></name></type> <name>classProbs</name></decl></parameter>,
      <parameter><decl><type><name>double</name></type> <name>totalWeight</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <comment type="line">// Make leaf if there are no training instances</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>m_Attribute</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>m_Distribution</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>m_Prop</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>double</name></type> <name>priorVar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

        <comment type="line">// Compute prior variance</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>totalSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totalSumSquared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totalSumOfWeights</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>totalSum</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>totalSumSquared</name> <operator>+=</operator>
            <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>totalSumOfWeights</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>priorVar</name> <operator>=</operator>
          <call><name><name>RandomTree</name><operator>.</operator><name>singleVariance</name></name><argument_list>(<argument><expr><name>totalSum</name></expr></argument>, <argument><expr><name>totalSumSquared</name></expr></argument>,
            <argument><expr><name>totalSumOfWeights</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// Check if node doesn't contain enough instances or is pure</comment>
      <comment type="line">// or maximum depth reached</comment>
      <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <call><name><name>classProbs</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/*
       * if (Utils.sum(m_ClassDistribution) &lt; 2 * m_MinNum ||
       * Utils.eq(m_ClassDistribution[Utils.maxIndex(m_ClassDistribution)],
       * Utils .sum(m_ClassDistribution))) {
       * 
       * // Make leaf m_Attribute = -1; m_Prop = null; return; }
       */</comment>

      <comment type="line">// Are we at an inner node</comment>
      <if_stmt><if>if <condition>(<expr><name>m_Attribute</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

        <comment type="line">// Compute new weights for subsets based on backfit data</comment>
        <expr_stmt><expr><name>m_Prop</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><name><name>m_Successors</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>inst</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name><name>m_Prop</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><name><name>m_Prop</name><index>[<expr><ternary><condition><expr><operator>(</operator><call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>m_SplitPoint</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name> <operator>+=</operator>
                <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// If we only have missing values we can make this node into a leaf</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name>m_Prop</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>m_Attribute</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>m_Prop</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>m_Distribution</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_Distribution</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>priorVar</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_Distribution</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>totalWeight</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Otherwise normalize the proportions</comment>
        <expr_stmt><expr><call><name><name>Utils</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name>m_Prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Split data</comment>
        <decl_stmt><decl><type><name><name>Instances</name><index>[]</index></name></type> <name>subsets</name> <init>= <expr><call><name>splitData</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Go through subsets</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>subsets</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

          <comment type="line">// Compute distribution for current subset</comment>
          <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>dist</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>data</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>sumOfWeights</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>numInstances</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name><name>dist</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>instance</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>classValue</name><argument_list>()</argument_list></call></expr>]</index></name> <operator>+=</operator>
                <name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>instance</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>weight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><name><name>dist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator>
                <name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>instance</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>classValue</name><argument_list>()</argument_list></call>
                  <operator>*</operator> <name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>instance</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>weight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>sumOfWeights</name> <operator>+=</operator> <name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>instance</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>weight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>

          <if_stmt><if>if <condition>(<expr><name>sumOfWeights</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>dist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/=</operator> <name>sumOfWeights</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="line">// Backfit subset</comment>
          <expr_stmt><expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>backfitData</name><argument_list>(<argument><expr><name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>totalWeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// If unclassified instances are allowed, we don't need to store the</comment>
        <comment type="line">// class distribution</comment>
        <if_stmt><if>if <condition>(<expr><call><name>getAllowUnclassifiedInstances</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>subsets</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m_ClassDistribution</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <return>return;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>

        <comment type="line">// If we have a least two non-empty successors, we should keep this tree</comment>
        <comment type="block">/*
         * int nonEmptySuccessors = 0; for (int i = 0; i &lt; subsets.length; i++)
         * { if (m_Successors[i].m_ClassDistribution != null) {
         * nonEmptySuccessors++; if (nonEmptySuccessors &gt; 1) { return; } } }
         * 
         * // Otherwise, this node is a leaf or should become a leaf
         * m_Successors = null; m_Attribute = -1; m_Prop = null; return;
         */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Recursively generates a tree.
     * 
     * @param data the data to work with
     * @param classProbs the class distribution
     * @param attIndicesWindow the attribute window to choose attributes from
     * @param random random number generator for choosing random attributes
     * @param depth the current depth
     * @throws Exception if generation fails
     */</comment>
    <function><type><specifier>protected</specifier> <name>void</name></type> <name>buildTree</name><parameter_list>(<parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name><name>double</name><index>[]</index></name></type> <name>classProbs</name></decl></parameter>,
      <parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>attIndicesWindow</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalWeight</name></decl></parameter>, <parameter><decl><type><name>Random</name></type> <name>random</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>,
      <parameter><decl><type><name>double</name></type> <name>minVariance</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <comment type="line">// Make leaf if there are no training instances</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>m_Attribute</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_Prop</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>m_Distribution</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>double</name></type> <name>priorVar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

        <comment type="line">// Compute prior variance</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>totalSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totalSumSquared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totalSumOfWeights</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>totalSum</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>totalSumSquared</name> <operator>+=</operator>
            <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>totalSumOfWeights</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>priorVar</name> <operator>=</operator>
          <call><name><name>RandomTree</name><operator>.</operator><name>singleVariance</name></name><argument_list>(<argument><expr><name>totalSum</name></expr></argument>, <argument><expr><name>totalSumSquared</name></expr></argument>,
            <argument><expr><name>totalSumOfWeights</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// Check if node doesn't contain enough instances or is pure</comment>
      <comment type="line">// or maximum depth reached</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>totalWeight</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name>classProbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="line">// System.err.println("Total weight " + totalWeight);</comment>
      <comment type="line">// double sum = Utils.sum(classProbs);</comment>
      <if_stmt><if>if <condition>(<expr><name>totalWeight</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>m_MinNum</name> <operator>||</operator>

      <comment type="line">// Nominal case</comment>
        <operator>(</operator><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Utils</name><operator>.</operator><name>eq</name></name><argument_list>(
          <argument><expr><name><name>classProbs</name><index>[<expr><call><name><name>Utils</name><operator>.</operator><name>maxIndex</name></name><argument_list>(<argument><expr><name>classProbs</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name>classProbs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator>

        <operator>||</operator>

        <comment type="line">// Numeric case</comment>
        <operator>(</operator><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>priorVar</name> <operator>/</operator> <name>totalWeight</name> <operator>&lt;</operator> <name>minVariance</name><operator>)</operator>

        <operator>||</operator>

        <comment type="line">// check tree depth</comment>
        <operator>(</operator><operator>(</operator><call><name>getMaxDepth</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>depth</name> <operator>&gt;=</operator> <call><name>getMaxDepth</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

        <comment type="line">// Make leaf</comment>
        <expr_stmt><expr><name>m_Attribute</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <call><name><name>classProbs</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>m_Distribution</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>m_Distribution</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>priorVar</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>m_Distribution</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>totalWeight</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>m_Prop</name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// Compute class distributions and value of splitting</comment>
      <comment type="line">// criterion for each attribute</comment>
      <decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><operator>-</operator><name><name>Double</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>split</name> <init>= <expr><operator>-</operator><name><name>Double</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>bestDists</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>bestProps</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>bestIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <comment type="line">// Handles to get arrays out of distribution method</comment>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>props</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index><index>[]</index><index>[]</index></name></type> <name>dists</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>totalSubsetWeights</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <comment type="line">// Investigate K random attributes</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>attIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>windowSize</name> <init>= <expr><name><name>attIndicesWindow</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name>m_KValue</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>boolean</name></type> <name>gainFound</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>tempNumericVals</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>data</name><operator>.</operator><name>numAttributes</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><operator>(</operator><name>windowSize</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>gainFound</name><operator>)</operator></expr>)</condition> <block>{<block_content>

        <decl_stmt><decl><type><name>int</name></type> <name>chosenIndex</name> <init>= <expr><call><name><name>random</name><operator>.</operator><name>nextInt</name></name><argument_list>(<argument><expr><name>windowSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>attIndex</name> <operator>=</operator> <name><name>attIndicesWindow</name><index>[<expr><name>chosenIndex</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="line">// shift chosen attIndex out of window</comment>
        <expr_stmt><expr><name><name>attIndicesWindow</name><index>[<expr><name>chosenIndex</name></expr>]</index></name> <operator>=</operator> <name><name>attIndicesWindow</name><index>[<expr><name>windowSize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>attIndicesWindow</name><index>[<expr><name>windowSize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>attIndex</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>windowSize</name><operator>--</operator></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>currSplit</name> <init>=
          <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>distribution</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>dists</name></expr></argument>,
            <argument><expr><name>attIndex</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>numericDistribution</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>dists</name></expr></argument>, <argument><expr><name>attIndex</name></expr></argument>,
            <argument><expr><name>totalSubsetWeights</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>tempNumericVals</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>currVal</name> <init>=
          <expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>gain</name><argument_list>(<argument><expr><name><name>dists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>priorVal</name><argument_list>(<argument><expr><name><name>dists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
            </then><else>: <expr><name><name>tempNumericVals</name><index>[<expr><name>attIndex</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name><name>Utils</name><operator>.</operator><name>gr</name></name><argument_list>(<argument><expr><name>currVal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>gainFound</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>currVal</name> <operator>&gt;</operator> <name>val</name><operator>)</operator>
          <operator>||</operator> <operator>(</operator><operator>(</operator><operator>!</operator><call><name>getBreakTiesRandomly</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>currVal</name> <operator>==</operator> <name>val</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>attIndex</name> <operator>&lt;</operator> <name>bestIndex</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>val</name> <operator>=</operator> <name>currVal</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bestIndex</name> <operator>=</operator> <name>attIndex</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>split</name> <operator>=</operator> <name>currSplit</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bestProps</name> <operator>=</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bestDists</name> <operator>=</operator> <name><name>dists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>

      <comment type="line">// Find best attribute</comment>
      <expr_stmt><expr><name>m_Attribute</name> <operator>=</operator> <name>bestIndex</name></expr>;</expr_stmt>

      <comment type="line">// Any useful split found?</comment>
      <if_stmt><if>if <condition>(<expr><call><name><name>Utils</name><operator>.</operator><name>gr</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>m_computeImpurityDecreases</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>m_impurityDecreasees</name><index>[<expr><name>m_Attribute</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>m_impurityDecreasees</name><index>[<expr><name>m_Attribute</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Build subtrees</comment>
        <expr_stmt><expr><name>m_SplitPoint</name> <operator>=</operator> <name>split</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_Prop</name> <operator>=</operator> <name>bestProps</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Instances</name><index>[]</index></name></type> <name>subsets</name> <init>= <expr><call><name>splitData</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>m_Successors</name> <operator>=</operator> <operator>new</operator> <name><name>Tree</name><index>[<expr><name><name>bestDists</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>attTotalSubsetWeights</name> <init>= <expr><name><name>totalSubsetWeights</name><index>[<expr><name>bestIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bestDists</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Tree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>buildTree</name><argument_list>(<argument><expr><name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bestDists</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>attIndicesWindow</name></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>attTotalSubsetWeights</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></argument>,
            <argument><expr><name>random</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>minVariance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// If all successors are non-empty, we don't need to store the class</comment>
        <comment type="line">// distribution</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>emptySuccessor</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>subsets</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m_ClassDistribution</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>emptySuccessor</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>emptySuccessor</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <call><name><name>classProbs</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>

        <comment type="line">// Make leaf</comment>
        <expr_stmt><expr><name>m_Attribute</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>m_ClassDistribution</name> <operator>=</operator> <call><name><name>classProbs</name><operator>.</operator><name>clone</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>classAttribute</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>m_Distribution</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>m_Distribution</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>priorVar</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>m_Distribution</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>totalWeight</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Computes size of the tree.
     * 
     * @return the number of nodes
     */</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>numNodes</name><parameter_list>()</parameter_list> <block>{<block_content>

      <if_stmt><if>if <condition>(<expr><name>m_Attribute</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Tree</name></type> <name>m_Successor</name> <range>: <expr><name>m_Successors</name></expr></range></decl></init>)</control> <block>{<block_content>
          <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name><name>m_Successor</name><operator>.</operator><name>numNodes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>size</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Splits instances into subsets based on the given split.
     * 
     * @param data the data to work with
     * @return the subsets of instances
     * @throws Exception if something goes wrong
     */</comment>
    <function><type><specifier>protected</specifier> <name><name>Instances</name><index>[]</index></name></type> <name>splitData</name><parameter_list>(<parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <comment type="line">// Allocate array of Instances objects</comment>
      <decl_stmt><decl><type><name><name>Instances</name><index>[]</index></name></type> <name>subsets</name> <init>= <expr><operator>new</operator> <name><name>Instances</name><index>[<expr><name><name>m_Prop</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_Prop</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Instances</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <comment type="line">// Go through the data</comment>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

        <comment type="line">// Get instance</comment>
        <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Does the instance have a missing value?</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>inst</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

          <comment type="line">// Split instance up</comment>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>m_Prop</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>m_Prop</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <decl_stmt><decl><type><name>Instance</name></type> <name>copy</name> <init>= <expr><operator>(</operator><name>Instance</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>copy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>copy</name><operator>.</operator><name>setWeight</name></name><argument_list>(<argument><expr><name><name>m_Prop</name><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>subsets</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><call><name>add</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>

          <comment type="line">// Proceed to next instance</comment>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Do we have a nominal attribute?</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNominal</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>subsets</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><call><name>add</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="line">// Proceed to next instance</comment>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Do we have a numeric attribute?</comment>
        <if_stmt><if>if <condition>(<expr><call><name><name>data</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>subsets</name><index>[<expr><ternary><condition><expr><operator>(</operator><call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>m_SplitPoint</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name><operator>.</operator><call><name>add</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="line">// Proceed to next instance</comment>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Else throw an exception</comment>
        <throw>throw <expr><operator>new</operator> <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><literal type="string">"Unknown attribute type"</literal></expr></argument>)</argument_list></call></expr>;</throw>
      </block_content>}</block></for>

      <comment type="line">// Save memory</comment>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_Prop</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>subsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>compactify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <comment type="line">// Return the subsets</comment>
      <return>return <expr><name>subsets</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Computes numeric class distribution for an attribute
     * 
     * @param props
     * @param dists
     * @param att
     * @param subsetWeights
     * @param data
     * @param vals
     * @return
     * @throws Exception if a problem occurs
     */</comment>
    <function><type><specifier>protected</specifier> <name>double</name></type> <name>numericDistribution</name><parameter_list>(<parameter><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>props</name></decl></parameter>, <parameter><decl><type><name><name>double</name><index>[]</index><index>[]</index><index>[]</index></name></type> <name>dists</name></decl></parameter>,
      <parameter><decl><type><name>int</name></type> <name>att</name></decl></parameter>, <parameter><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>subsetWeights</name></decl></parameter>, <parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name><name>double</name><index>[]</index></name></type> <name>vals</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <decl_stmt><decl><type><name>double</name></type> <name>splitPoint</name> <init>= <expr><name><name>Double</name><operator>.</operator><name>NaN</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Attribute</name></type> <name>attribute</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>dist</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>sums</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>sumSquared</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>sumOfWeights</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>totalSum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totalSumSquared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totalSumOfWeights</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>indexOfFirstMissingValue</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><call><name><name>attribute</name><operator>.</operator><name>isNominal</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>sums</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>attribute</name><operator>.</operator><name>numValues</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumSquared</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>attribute</name><operator>.</operator><name>numValues</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumOfWeights</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>attribute</name><operator>.</operator><name>numValues</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>attVal</name></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name><name>inst</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

            <comment type="line">// Skip missing values at this stage</comment>
            <if_stmt><if>if <condition>(<expr><name>indexOfFirstMissingValue</name> <operator>==</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>indexOfFirstMissingValue</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name>attVal</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sums</name><index>[<expr><name>attVal</name></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sumSquared</name><index>[<expr><name>attVal</name></expr>]</index></name> <operator>+=</operator>
            <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sumOfWeights</name><index>[<expr><name>attVal</name></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>totalSum</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name>sums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSumSquared</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name>sumSquared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSumOfWeights</name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name>sumOfWeights</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// For numeric attributes</comment>
        <expr_stmt><expr><name>sums</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumSquared</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumOfWeights</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>currSums</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>currSumSquared</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>double</name><index>[]</index></name></type> <name>currSumOfWeights</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Sort data</comment>
        <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Move all instances into second subset</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name><name>inst</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

            <comment type="line">// Can stop as soon as we hit a missing value</comment>
            <expr_stmt><expr><name>indexOfFirstMissingValue</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name><name>currSums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>currSumSquared</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator>
            <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>currSumOfWeights</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>totalSum</name> <operator>=</operator> <name><name>currSums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSumSquared</name> <operator>=</operator> <name><name>currSumSquared</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSumOfWeights</name> <operator>=</operator> <name><name>currSumOfWeights</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>sums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>currSums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sumSquared</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>currSumSquared</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sumOfWeights</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>currSumOfWeights</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <comment type="line">// Try all possible split points</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>currSplit</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>value</name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>currVal</name></decl>, <decl><type ref="prev"/><name>bestVal</name> <init>= <expr><name><name>Double</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indexOfFirstMissingValue</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>currSplit</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>currVal</name> <operator>=</operator>
              <call><name><name>RandomTree</name><operator>.</operator><name>variance</name></name><argument_list>(<argument><expr><name>currSums</name></expr></argument>, <argument><expr><name>currSumSquared</name></expr></argument>, <argument><expr><name>currSumOfWeights</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>currVal</name> <operator>&lt;</operator> <name>bestVal</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>bestVal</name> <operator>=</operator> <name>currVal</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>splitPoint</name> <operator>=</operator> <operator>(</operator><call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>currSplit</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>

              <comment type="line">// Check for numeric precision problems</comment>
              <if_stmt><if>if <condition>(<expr><name>splitPoint</name> <operator>&lt;=</operator> <name>currSplit</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>splitPoint</name> <operator>=</operator> <call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>

              <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>sums</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>currSums</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sumSquared</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>currSumSquared</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sumOfWeights</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>currSumOfWeights</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
              </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name>currSplit</name> <operator>=</operator> <call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <decl_stmt><decl><type><name>double</name></type> <name>classVal</name> <init>= <expr><call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>classValSquared</name> <init>= <expr><call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>classVal</name></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name><name>currSums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>classVal</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>currSumSquared</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>classValSquared</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>currSumOfWeights</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>currSums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <name>classVal</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>currSumSquared</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <name>classValSquared</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>currSumOfWeights</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>

      <comment type="line">// Compute weights</comment>
      <expr_stmt><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><name><name>sums</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>length</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>sumOfWeights</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>length</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>length</name></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>Utils</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="line">// Distribute weights for instances with missing values</comment>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>indexOfFirstMissingValue</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sums</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>sums</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sumSquared</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator>
            <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sumOfWeights</name><index>[<expr><name>j</name></expr>]</index></name> <operator>+=</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>totalSum</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSumSquared</name> <operator>+=</operator>
          <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalSumOfWeights</name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <comment type="line">// Compute final distribution</comment>
      <expr_stmt><expr><name>dist</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><name><name>sums</name><operator>.</operator><name>length</name></name></expr>]</index><index>[<expr><call><name><name>data</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sums</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>sumOfWeights</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sums</name><index>[<expr><name>j</name></expr>]</index></name> <operator>/</operator> <name><name>sumOfWeights</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>totalSum</name> <operator>/</operator> <name>totalSumOfWeights</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

      <comment type="line">// Compute variance gain</comment>
      <decl_stmt><decl><type><name>double</name></type> <name>priorVar</name> <init>=
        <expr><call><name>singleVariance</name><argument_list>(<argument><expr><name>totalSum</name></expr></argument>, <argument><expr><name>totalSumSquared</name></expr></argument>, <argument><expr><name>totalSumOfWeights</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>var</name> <init>= <expr><call><name>variance</name><argument_list>(<argument><expr><name>sums</name></expr></argument>, <argument><expr><name>sumSquared</name></expr></argument>, <argument><expr><name>sumOfWeights</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>gain</name> <init>= <expr><name>priorVar</name> <operator>-</operator> <name>var</name></expr></init></decl>;</decl_stmt>

      <comment type="line">// Return distribution and split point</comment>
      <expr_stmt><expr><name><name>subsetWeights</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <name>sumOfWeights</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>dist</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>vals</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <name>gain</name></expr>;</expr_stmt>

      <return>return <expr><name>splitPoint</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Computes class distribution for an attribute.
     * 
     * @param props
     * @param dists
     * @param att the attribute index
     * @param data the data to work with
     * @throws Exception if something goes wrong
     */</comment>
    <function><type><specifier>protected</specifier> <name>double</name></type> <name>distribution</name><parameter_list>(<parameter><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>props</name></decl></parameter>, <parameter><decl><type><name><name>double</name><index>[]</index><index>[]</index><index>[]</index></name></type> <name>dists</name></decl></parameter>,
      <parameter><decl><type><name>int</name></type> <name>att</name></decl></parameter>, <parameter><decl><type><name>Instances</name></type> <name>data</name></decl></parameter>)</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <decl_stmt><decl><type><name>double</name></type> <name>splitPoint</name> <init>= <expr><name><name>Double</name><operator>.</operator><name>NaN</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Attribute</name></type> <name>attribute</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>dist</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>indexOfFirstMissingValue</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><call><name><name>attribute</name><operator>.</operator><name>isNominal</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

        <comment type="line">// For nominal attributes</comment>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><call><name><name>attribute</name><operator>.</operator><name>numValues</name></name><argument_list>()</argument_list></call></expr>]</index><index>[<expr><call><name><name>data</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name><name>inst</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

            <comment type="line">// Skip missing values at this stage</comment>
            <if_stmt><if>if <condition>(<expr><name>indexOfFirstMissingValue</name> <operator>==</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>indexOfFirstMissingValue</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>dist</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if> <else>else <block>{<block_content>

        <comment type="line">// For numeric attributes</comment>
        <decl_stmt><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>currDist</name> <init>= <expr><operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><call><name><name>data</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>dist</name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><call><name><name>data</name><operator>.</operator><name>numClasses</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

        <comment type="line">// Sort data</comment>
        <expr_stmt><expr><call><name><name>data</name><operator>.</operator><name>sort</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Move all instances into second subset</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name><name>inst</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

            <comment type="line">// Can stop as soon as we hit a missing value</comment>
            <expr_stmt><expr><name>indexOfFirstMissingValue</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>currDist</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Value before splitting</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>priorVal</name> <init>= <expr><call><name>priorVal</name><argument_list>(<argument><expr><name>currDist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Save initial distribution</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>currDist</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name><name>currDist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Try all possible split points</comment>
        <decl_stmt><decl><type><name>double</name></type> <name>currSplit</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>value</name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>currVal</name></decl>, <decl><type ref="prev"/><name>bestVal</name> <init>= <expr><operator>-</operator><name><name>Double</name><operator>.</operator><name>MAX_VALUE</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indexOfFirstMissingValue</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>double</name></type> <name>attVal</name> <init>= <expr><call><name><name>inst</name><operator>.</operator><name>value</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="line">// Can we place a sensible split point here?</comment>
          <if_stmt><if>if <condition>(<expr><name>attVal</name> <operator>&gt;</operator> <name>currSplit</name></expr>)</condition> <block>{<block_content>

            <comment type="line">// Compute gain for split point</comment>
            <expr_stmt><expr><name>currVal</name> <operator>=</operator> <call><name>gain</name><argument_list>(<argument><expr><name>currDist</name></expr></argument>, <argument><expr><name>priorVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Is the current split point the best point so far?</comment>
            <if_stmt><if>if <condition>(<expr><name>currVal</name> <operator>&gt;</operator> <name>bestVal</name></expr>)</condition> <block>{<block_content>

              <comment type="line">// Store value of current point</comment>
              <expr_stmt><expr><name>bestVal</name> <operator>=</operator> <name>currVal</name></expr>;</expr_stmt>

              <comment type="line">// Save split point</comment>
              <expr_stmt><expr><name>splitPoint</name> <operator>=</operator> <operator>(</operator><name>attVal</name> <operator>+</operator> <name>currSplit</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>

              <comment type="line">// Check for numeric precision problems</comment>
              <if_stmt><if>if <condition>(<expr><name>splitPoint</name> <operator>&lt;=</operator> <name>currSplit</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>splitPoint</name> <operator>=</operator> <name>attVal</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>

              <comment type="line">// Save distribution</comment>
              <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>currDist</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>arraycopy</name></name><argument_list>(<argument><expr><name><name>currDist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Update value</comment>
            <expr_stmt><expr><name>currSplit</name> <operator>=</operator> <name>attVal</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

          <comment type="line">// Shift over the weight</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>classVal</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>currDist</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>classVal</name></expr>]</index></name> <operator>+=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>currDist</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>classVal</name></expr>]</index></name> <operator>-=</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>

      <comment type="line">// Compute weights for subsets</comment>
      <expr_stmt><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>new</operator> <name><name>double</name><index>[<expr><name><name>dist</name><operator>.</operator><name>length</name></name></expr>]</index></name></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>length</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name><name>dist</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><call><name><name>Utils</name><operator>.</operator><name>eq</name></name><argument_list>(<argument><expr><call><name><name>Utils</name><operator>.</operator><name>sum</name></name><argument_list>(<argument><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>length</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>length</name></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>Utils</name><operator>.</operator><name>normalize</name></name><argument_list>(<argument><expr><name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="line">// Distribute weights for instances with missing values</comment>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>indexOfFirstMissingValue</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>data</name><operator>.</operator><name>numInstances</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>Instance</name></type> <name>inst</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>instance</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>attribute</name><operator>.</operator><name>isNominal</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

          <comment type="line">// Need to check if attribute value is missing</comment>
          <if_stmt><if>if <condition>(<expr><call><name><name>inst</name><operator>.</operator><name>isMissing</name></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dist</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
              <expr_stmt><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call></expr>]</index></name> <operator>+=</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>

          <comment type="line">// Can be sure that value is missing, so no test required</comment>
          <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dist</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><name><name>dist</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>inst</name><operator>.</operator><name>classValue</name></name><argument_list>()</argument_list></call></expr>]</index></name> <operator>+=</operator> <name><name>props</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <call><name><name>inst</name><operator>.</operator><name>weight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

      <comment type="line">// Return distribution and split point</comment>
      <expr_stmt><expr><name><name>dists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>dist</name></expr>;</expr_stmt>
      <return>return <expr><name>splitPoint</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Computes value of splitting criterion before split.
     * 
     * @param dist the distributions
     * @return the splitting criterion
     */</comment>
    <function><type><specifier>protected</specifier> <name>double</name></type> <name>priorVal</name><parameter_list>(<parameter><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>dist</name></decl></parameter>)</parameter_list> <block>{<block_content>

      <return>return <expr><call><name><name>ContingencyTables</name><operator>.</operator><name>entropyOverColumns</name></name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Computes value of splitting criterion after split.
     * 
     * @param dist the distributions
     * @param priorVal the splitting criterion
     * @return the gain after the split
     */</comment>
    <function><type><specifier>protected</specifier> <name>double</name></type> <name>gain</name><parameter_list>(<parameter><decl><type><name><name>double</name><index>[]</index><index>[]</index></name></type> <name>dist</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>priorVal</name></decl></parameter>)</parameter_list> <block>{<block_content>

      <return>return <expr><name>priorVal</name> <operator>-</operator> <call><name><name>ContingencyTables</name><operator>.</operator><name>entropyConditionedOnRows</name></name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the revision string.
     * 
     * @return the revision
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getRevision</name><parameter_list>()</parameter_list> <block>{<block_content>
      <return>return <expr><call><name><name>RevisionUtils</name><operator>.</operator><name>extract</name></name><argument_list>(<argument><expr><literal type="string">"$Revision$"</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block" format="javadoc">/**
     * Outputs one node for graph.
     * 
     * @param text the buffer to append the output to
     * @param num the current node id
     * @param parent the parent of the nodes
     * @return the next node id
     * @throws Exception if something goes wrong
     */</comment>
    <function><type><specifier>protected</specifier> <name>int</name></type> <name>toGraph</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>Tree</name></type> <name>parent</name></decl></parameter>)</parameter_list>
      <throws>throws <argument><expr><name>Exception</name></expr></argument></throws> <block>{<block_content>

      <expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>m_Attribute</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"N"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>Tree</name><operator>.</operator><name>this</name><operator>.</operator><name>hashCode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
          <operator>+</operator> <literal type="string">" [label=\""</literal> <operator>+</operator> <name>num</name> <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>backQuoteChars</name></name><argument_list>(<argument><expr><call><name>leafString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"\""</literal>
          <operator>+</operator> <literal type="string">" shape=box]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"N"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>Tree</name><operator>.</operator><name>this</name><operator>.</operator><name>hashCode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
          <operator>+</operator> <literal type="string">" [label=\""</literal> <operator>+</operator> <name>num</name> <operator>+</operator> <literal type="string">": "</literal>
          <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>backQuoteChars</name></name><argument_list>(<argument><expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>name</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
          <operator>+</operator> <literal type="string">"\"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_Successors</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"N"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><call><name><name>Tree</name><operator>.</operator><name>this</name><operator>.</operator><name>hashCode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"-&gt;"</literal>
            <operator>+</operator> <literal type="string">"N"</literal> <operator>+</operator> <call><name><name>Integer</name><operator>.</operator><name>toHexString</name></name><argument_list>(<argument><expr><name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>hashCode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
            <operator>+</operator> <literal type="string">" [label=\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNumeric</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &lt; "</literal>
                <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>m_SplitPoint</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" &gt;= "</literal>
                <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>doubleToString</name></name><argument_list>(<argument><expr><name>m_SplitPoint</name></expr></argument>, <argument><expr><call><name>getNumDecimalPlaces</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">" = "</literal>
              <operator>+</operator> <call><name><name>Utils</name><operator>.</operator><name>backQuoteChars</name></name><argument_list>(<argument><expr><call><name><name>m_Info</name><operator>.</operator><name>attribute</name></name><argument_list>(<argument><expr><name>m_Attribute</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>value</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name><name>text</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><literal type="string">"\"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>m_Successors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>toGraph</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>

      <return>return <expr><name>num</name></expr>;</return>
    </block_content>}</block></function>
  }</block></class>

  <comment type="block" format="javadoc">/**
   * Computes variance for subsets.
   * 
   * @param s
   * @param sS
   * @param sumOfWeights
   * @return the variance
   */</comment>
  <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>double</name></type> <name>variance</name><parameter_list>(<parameter><decl><type><name><name>double</name><index>[]</index></name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name><name>double</name><index>[]</index></name></type> <name>sS</name></decl></parameter>,
    <parameter><decl><type><name><name>double</name><index>[]</index></name></type> <name>sumOfWeights</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <decl_stmt><decl><type><name>double</name></type> <name>var</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>.</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>sumOfWeights</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>var</name> <operator>+=</operator> <call><name>singleVariance</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sS</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sumOfWeights</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>var</name></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Computes the variance for a single set
   * 
   * @param s
   * @param sS
   * @param weight the weight
   * @return the variance
   */</comment>
  <function><type><specifier>protected</specifier> <specifier>static</specifier> <name>double</name></type> <name>singleVariance</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>sS</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>weight</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <return>return <expr><name>sS</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>s</name> <operator>*</operator> <name>s</name><operator>)</operator> <operator>/</operator> <name>weight</name><operator>)</operator></expr>;</return>
  </block_content>}</block></function>

  <comment type="block" format="javadoc">/**
   * Main method for this class.
   * 
   * @param argv the commandline parameters
   */</comment>
  <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name><name>String</name><index>[]</index></name></type> <name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>runClassifier</name><argument_list>(<argument><expr><operator>new</operator> <call><name>RandomTree</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></function>
}</block></class>
</unit>

--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -212,7 +212,7 @@
     detachClause(cr);
     // Don't leave pointers to free'd memory!
     if (locked(c)) /*auto*/{
-      vardata[var(c[0])].reason = CRef_Undef;
+      
     }/*auto*/
     c.mark(1); 
     ca.free(cr);
@@ -480,7 +480,7 @@
         Var x = var(trail[i]);
         if (seen[x]){
             if (reason(x) == CRef_Undef){
-                assert(level(x) > 0);
+                
                 out_conflict.push(~trail[i]);
             }else{
                 Clause& c = ca[reason(x)];
@@ -764,14 +764,11 @@
             if (nof_conflicts >= 0 && conflictC >= nof_conflicts || !withinBudget()){
                 // Reached bound on number of conflicts:
                 progress_estimate = progressEstimate();
-                cancelUntil(0);
+                
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
-            if (decisionLevel() == 0 && !simplify())
-                /*auto*/{
-                    return l_False;
-                }/*auto*/
+            
 
             if (learnts.size()-nAssigns() >= max_learnts)
                 // Reduce the set of learnt clauses:
@@ -785,6 +782,7 @@
                 Lit p = assumptions[decisionLevel()];
                 if (value(p) == l_True){
                     // Dummy decision level:
+                    conflictC++;
                     newDecisionLevel();
                 }else if (value(p) == l_False){
                     analyzeFinal(~p, conflict);
@@ -1065,6 +1063,7 @@
     for (int i = 0; i < clauses.size(); i++)
         /*auto*/{
             ca.reloc(clauses[i], to);
+            return false;
         }/*auto*/
 }
 

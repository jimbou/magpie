--- before: sources/core/Solver.cc
+++ after: sources/core/Solver.cc
@@ -827,6 +827,20 @@
             if (!luby_restart){
                 gS += L;
                 PUSH(LQ, L, 50, lS);
+                if (!luby_restart){
+                    PUSH(TQ, trail.size(), 5000, tS);
+                    if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)/*auto*/{
+                        
+                        lS = 0, LQ.clear();
+                    }/*auto*/
+                }
+                if (!luby_restart){
+                    PUSH(TQ, trail.size(), 5000, tS);
+                    if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)/*auto*/{
+                        
+                        lS = 0, LQ.clear();
+                    }/*auto*/
+                }
             }
 
             if (learnt_clause.size() == 1){
@@ -846,6 +860,7 @@
                 }/*auto*/
                 uncheckedEnqueue(learnt_clause[0], cr);
             }
+            static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
             /*if (output != NULL) {
               for (int i = 0; i < learnt_clause.size(); i++)
                 fprintf(output, "%i " , (var(learnt_clause[i]) + 1) *
@@ -1003,7 +1018,7 @@
 // NOTE: assumptions passed in member-variable 'assumptions'.
 lbool Solver::solve_()
 {
-    model.clear();
+    
     conflict.clear();
     if (!ok)/*auto*/{
        return l_False;

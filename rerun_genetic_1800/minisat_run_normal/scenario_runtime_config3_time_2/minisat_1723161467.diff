--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -483,6 +483,10 @@
                 assert(level(x) > 0);
                 out_conflict.push(~trail[i]);
             }else{
+                break;
+                break;
+                break;
+                break;
                 Clause& c = ca[reason(x)];
                 for (int j = 1; j < c.size(); j++)
                     /*auto*/{
@@ -503,6 +507,7 @@
 void Solver::uncheckedEnqueue(Lit p, CRef from)
 {
     assert(value(p) == l_Undef);
+    double  F = 1.0 / nVars();
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
@@ -672,10 +677,7 @@
 {
     assert(decisionLevel() == 0);
 
-    if (!ok || propagate() != CRef_Undef)
-        /*auto*/{
-            return ok = false;
-        }/*auto*/
+    max_learnts               = nClauses() * learntsize_factor;
 
     if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
         /*auto*/{
@@ -764,7 +766,7 @@
             if (nof_conflicts >= 0 && conflictC >= nof_conflicts || !withinBudget()){
                 // Reached bound on number of conflicts:
                 progress_estimate = progressEstimate();
-                cancelUntil(0);
+                
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
@@ -937,10 +939,7 @@
 
     for (int i = 0; i < c.size(); i++)
         /*auto*/{
-            if (value(c[i]) != l_False)
-            /*auto*/{
-                fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
-            }/*auto*/
+            
         }/*auto*/
     fprintf(f, "0\n");
 }

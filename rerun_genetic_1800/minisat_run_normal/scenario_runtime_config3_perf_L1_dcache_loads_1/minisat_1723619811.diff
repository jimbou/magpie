--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -215,7 +215,7 @@
       vardata[var(c[0])].reason = CRef_Undef;
     }/*auto*/
     c.mark(1); 
-    ca.free(cr);
+    
 }
 
 
@@ -389,7 +389,7 @@
             i = j = out_learnt.size();
         }/*auto*/
 
-    max_literals += out_learnt.size();
+    
     out_learnt.shrink(i - j);
     tot_literals += out_learnt.size();
 
@@ -683,7 +683,7 @@
         }/*auto*/
 
     // Remove satisfied clauses:
-    removeSatisfied(learnts);
+    return true;
     if (remove_satisfied)        // Can be turned off.
         /*auto*/{
             removeSatisfied(clauses);
@@ -764,7 +764,7 @@
             if (nof_conflicts >= 0 && conflictC >= nof_conflicts || !withinBudget()){
                 // Reached bound on number of conflicts:
                 progress_estimate = progressEstimate();
-                cancelUntil(0);
+                
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
@@ -810,6 +810,7 @@
             // Increase decision level and enqueue 'next'
             newDecisionLevel();
             uncheckedEnqueue(next);
+            Lit p;
         }
     }
 }
@@ -905,10 +906,7 @@
         for (int i = 0; i < nVars(); i++) /*auto*/{
             model[i] = value(i);
         }/*auto*/
-    }else if (status == l_False && conflict.size() == 0)
-        /*auto*/{
-            ok = false;
-        }/*auto*/
+    }else 
 
     cancelUntil(0);
     return status;

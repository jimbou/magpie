--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -237,10 +237,7 @@
         for (int c = trail.size()-1; c >= trail_lim[level]; c--){
             Var      x  = var(trail[c]);
             assigns [x] = l_Undef;
-            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
-                /*auto*/{
-                    polarity[x] = sign(trail[c]);
-                }/*auto*/
+            
             insertVarOrder(x); }
         qhead = trail_lim[level];
         trail.shrink(trail.size() - trail_lim[level]);
@@ -745,26 +742,14 @@
             varDecayActivity();
             claDecayActivity();
 
-            if (--learntsize_adjust_cnt == 0){
-                learntsize_adjust_confl *= learntsize_adjust_inc;
-                learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
-                max_learnts             *= learntsize_inc;
-
-                if (verbosity >= 1)
-                    /*auto*/{
-                        printf("| %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n", 
-                           (int)conflicts, 
-                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
-                           (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
-                    }/*auto*/
-            }
+            
 
         }else{
             // NO CONFLICT
             if (nof_conflicts >= 0 && conflictC >= nof_conflicts || !withinBudget()){
                 // Reached bound on number of conflicts:
                 progress_estimate = progressEstimate();
-                cancelUntil(0);
+                
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
@@ -797,7 +782,7 @@
 
             if (next == lit_Undef){
                 // New variable decision:
-                decisions++;
+                
                 next = pickBranchLit();
 
                 if (next == lit_Undef)
@@ -922,7 +907,7 @@
 static Var mapVar(Var x, vec<Var>& map, Var& max)
 {
     if (map.size() <= x || map[x] == -1){
-        map.growTo(x+1, -1);
+        
         map[x] = max++;
     }
     return map[x];

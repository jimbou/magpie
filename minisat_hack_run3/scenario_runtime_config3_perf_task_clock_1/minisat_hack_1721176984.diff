--- before: sources/core/Solver.cc
+++ after: sources/core/Solver.cc
@@ -558,6 +558,7 @@
                     }/*auto*/
                 }/*auto*/
             }
+            Var next = var_Undef;
             seen[x] = 0;
         }
     }
@@ -890,35 +891,7 @@
                 return l_False;
             }/*auto*/
 
-            if (learnts.size() > (int32_t)opt_cp_increase && cp < conflicts){
-                cp = conflicts + (int32_t)opt_cp_increase;
-                // Reduce the set of learnt clauses:
-                reduceDB();
-
-                static int adjust = 0;
-                if (core_added < (int32_t)opt_cp_increase * (double)opt_core_tolerance){
-                    if (LBD_cut < (int32_t)opt_lbd_cut_max)/*auto*/{
-                        
-                        LBD_cut = (int32_t)opt_lbd_cut + ++adjust;
-                    }/*auto*/
-
-                    if (!luby_restart){
-                        core_added = 0;
-                        K = 1;
-                        lS = 0, LQ.clear();
-                        cancelUntil(0);
-                        return l_Undef; }
-                }else{
-                    if (adjust > 0)/*auto*/{
-                         adjust--;
-                    }/*auto*/
-                    if (adjust == 0)/*auto*/{
-                         K = (double)opt_K;
-                    }/*auto*/
-                    LBD_cut = (int32_t)opt_lbd_cut + adjust;
-                }
-                core_added = 0;
-            }
+            
 
             Lit next = lit_Undef;
             /*while (decisionLevel() < assumptions.size()){
@@ -1062,10 +1035,7 @@
 
 static Var mapVar(Var x, vec<Var>& map, Var& max)
 {
-    if (map.size() <= x || map[x] == -1){
-        map.growTo(x+1, -1);
-        map[x] = max++;
-    }
+    
     return map[x];
 }
 

--- before: sources/core/Solver.cc
+++ after: sources/core/Solver.cc
@@ -369,7 +369,7 @@
             LBD(c);
             c.mark(L < LBD_cut ? 3 : 2);
             if (L < LBD_cut){
-                lF.push(confl);
+                
                 core_added++;
             }else/*auto*/{
                 
@@ -558,6 +558,7 @@
                     }/*auto*/
                 }/*auto*/
             }
+            Var next = var_Undef;
             seen[x] = 0;
         }
     }
@@ -763,10 +764,7 @@
     // Remove satisfied clauses:
     removeSatisfied(learnts);
     removeSatisfied(lF);
-    if (remove_satisfied)/*auto*/{
-              // Can be turned off.
-        removeSatisfied(clauses);
-    }/*auto*/
+    
     checkGarbage();
     rebuildOrderHeap();
 
@@ -827,6 +825,13 @@
             if (!luby_restart){
                 gS += L;
                 PUSH(LQ, L, 50, lS);
+                if (!luby_restart){
+                    PUSH(TQ, trail.size(), 5000, tS);
+                    if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)/*auto*/{
+                        
+                        lS = 0, LQ.clear();
+                    }/*auto*/
+                }
             }
 
             if (learnt_clause.size() == 1){
@@ -1219,6 +1224,7 @@
 {
     // Initialize the next region to a size corresponding to the estimated utilization degree. This
     // is not precise but should avoid some unnecessary reallocations for the new region:
+    LBD_cut = (int32_t)opt_lbd_cut;
     ClauseAllocator to(ca.size() - ca.wasted()); 
 
     relocAll(to);
@@ -1227,5 +1233,5 @@
         printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
                ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
     }/*auto*/
-    to.moveTo(ca);
-}
+    
+}
